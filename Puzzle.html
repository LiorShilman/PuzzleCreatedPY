<!DOCTYPE html>
<html dir="rtl">

<head>
    <meta charset="UTF-8">
    <title>爪专 驻</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --accent-color: #3498db;
            --container-bg: #2d2d2d;
            --border-color: #404040;
            --glow-color: rgba(52, 152, 219, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            display: grid;
            grid-template-columns: minmax(280px, 380px) 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        .settings-panel {
            background: var(--container-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .preview-panel {
            background: var(--container-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-color);
            border-radius: 10px;
        }

        h2,
        h3 {
            color: var(--accent-color);
            margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        input[type="number"],
        input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-color);
        }

        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            width: 100%;
            margin-bottom: 10px;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .mode-toggle {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            /* 砖 砖专  */
            gap: 10px;
            margin: 15px 0;
            padding: 10px;
            background: var(--bg-color);
            border-radius: 8px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin-left: 10px;
            /* 砖 -margin-right -margin-left */
        }



        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--accent-color);
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .preview-container {
            width: 100%;
            aspect-ratio: 16/9;
            background: var(--bg-color);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .preview-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            flex-grow: 1;
            background: var(--bg-color);
            border-radius: 10px;
            overflow: hidden;
        }

        #puzzleCanvas {
            width: 100%;
            height: 100%;
        }

        .piece-container {
            position: absolute;
            cursor: grab;
            transform-origin: center;
            transition: transform 0.2s ease;
        }

        .piece-container.dragging {
            cursor: grabbing;
            z-index: 1000;
            animation: piece-glow 2s infinite;
            filter: drop-shadow(0 0 10px var(--glow-color));
        }

        @keyframes piece-glow {
            0% {
                filter: drop-shadow(0 0 10px var(--glow-color));
            }

            50% {
                filter: drop-shadow(0 0 20px var(--glow-color)) brightness(1.2);
            }

            100% {
                filter: drop-shadow(0 0 10px var(--glow-color));
            }
        }

        .pieces-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 10px;
            background: var(--bg-color);
            border-radius: 10px;
            height: 150px;
            overflow-y: auto;
        }

        .piece-preview {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.2s ease;
        }

        #status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #status.show {
            opacity: 1;
        }
		
		.puzzle-counter {
			position: fixed;
			top: 20px;
			right: 20px;
			background: linear-gradient(145deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.9));
			color: white;
			padding: 15px 25px;
			border-radius: 15px;
			font-size: 18px;
			font-weight: bold;
			text-align: center;
			transition: all 0.3s ease;
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
			z-index: 1000;
			direction: rtl;
		}

		.puzzle-counter.pulse {
			animation: counterPulse 0.3s ease;
		}

		@keyframes counterPulse {
			0% { transform: scale(1); }
			50% { transform: scale(1.1); }
			100% { transform: scale(1); }
		}

	

		/* 住 砖注 砖拽 */
		.game-timer {
		  position: absolute;
		  //top: 20px;
		  //right: 20px;
		  background: rgba(30, 30, 30, 0.85);
		  padding: 10px 15px;
		  border-radius: 8px;
		  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
		  backdrop-filter: blur(5px);
		  display: flex;
		  flex-direction: row; /* 砖 砖专 驻拽转 */
		  align-items: center;
		  gap: 10px;
		  z-index: 1000;
		  border: 1px solid rgba(255, 255, 255, 0.1);
		}

		.game-timer .timer-display {
		  font-family: monospace;
		  font-size: 24px;
		  font-weight: bold;
		  color: #e2e8f0;
		  margin: 0;
		}

		.game-timer .timer-controls {
		  display: flex;
		  gap: 8px;
		}

		.game-timer .timer-btn {
		  background: rgba(255, 255, 255, 0.1);
		  border: none;
		  cursor: pointer;
		  padding: 6px;
		  border-radius: 50%;
		  transition: all 0.2s ease;
		  display: flex;
		  align-items: center;
		  justify-content: center;
		}

		.game-timer .timer-btn:hover {
		  background: rgba(255, 255, 255, 0.2);
		}

		.game-timer .timer-btn svg {
		  width: 20px;
		  height: 20px;
		  fill: #e2e8f0;
		}
		
		#startPauseBtn {
			margin-bottom: 0px;
		}

		#resetBtn {
			margin-bottom: 0px;
		}

    </style>
</head>

<body>
    <div class="main-container">
        <div class="settings-panel">
            <div class="section">
                <h2>专转 驻</h2>
                <div class="input-group">
                    <label>注转 转:</label>
                    <input type="file" id="imageUpload" accept="image/*" />
                </div>

                <div class="radio-group">
                    <label>
                        <input type="radio" name="puzzleType" value="simple" checked>
                        驻 驻砖 ()
                    </label>
                    <label>
                        <input type="radio" name="puzzleType" value="classic">
                        驻 拽住 (爪专转 住专转转)
                    </label>
                </div>

                <div class="mode-toggle">
                    <label class="switch">
                        <input type="checkbox" id="modeToggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span>爪 专 (爪 转)</span>
                </div>

                <div class="input-group">
                    <label>住驻专 砖专转:</label>
                    <input type="number" id="rows" value="3" min="1" max="20">
                </div>

                <div class="input-group">
                    <label>住驻专 注转:</label>
                    <input type="number" id="cols" value="4" min="1" max="20">
                </div>

                <button onclick="handleCreatePuzzle()">爪专 驻</button>
                <button onclick="handleDownloadPieces()">专 拽</button>
            </div>
        </div>

        <div class="preview-panel">
            <div class="section">
                <h2>转爪 拽</h2>
                <div class="preview-container">
                    <img id="previewImage" class="preview-image">
                </div>
            </div>

            <div class="section canvas-section">
                <h2>专 砖拽</h2>
                <div class="canvas-container">
					<div class="game-timer">
						<div class="timer-display" id="timerDisplay">00:00:00</div>
						
						<div class="timer-controls">
						  <button class="timer-btn play-btn" id="startPauseBtn" title="转/砖">
							<svg viewBox="0 0 24 24" class="play-icon">
							  <path d="M8 5v14l11-7z"/>
							</svg>
							<svg viewBox="0 0 24 24" class="pause-icon" style="display: none;">
							  <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
							</svg>
						  </button>
						  
						  <button class="timer-btn reset-btn" id="resetBtn" title="驻住">
							<svg viewBox="0 0 24 24">
							  <path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
							</svg>
						  </button>
						</div>
					  </div>

                    <canvas id="puzzleCanvas"></canvas>
                </div>
            </div>
        </div>
		
		<!-- 住驻转  -->
		<div class="puzzle-counter"></div>
	
    </div>

    <div id="status"></div>

    <script>
        let originalImage = null;
        let puzzlePieces = [];
        let canvas;
        let ctx;
        let isDragging = false;
        let currentPiece = null;
        let offsetX = 0;
        let offsetY = 0;
        let piecePositions = [];
        let gridSize = { rows: 0, cols: 0 };
        let isGuidedMode = true;
        let edgeTypes = null;
        let completedPieces = 0;
        // 砖转  砖 注转 住住
        let statusTimeout = null;
		// 砖转  住  驻 砖
		let isPuzzleCompleted = false;
		let startTime;
		let timerInterval;
		let isRunning = false;
		let elapsedTime = 0;

		const snapDistance = 30;
		// 住驻转 驻拽爪转 
		let puzzleCounter = null;
		let totalPiecesCount = 0;
		// 住驻转 砖转   z-index
		let currentMaxZIndex = 1000;

        document.addEventListener('DOMContentLoaded', initialize);
		
		const timerDisplay = document.getElementById('timerDisplay');
		const startPauseBtn = document.getElementById('startPauseBtn');
		const resetBtn = document.getElementById('resetBtn');
		const playIcon = startPauseBtn.querySelector('.play-icon');
		const pauseIcon = startPauseBtn.querySelector('.pause-icon');

		function formatTime(totalSeconds) {
		  const hours = Math.floor(totalSeconds / 3600);
		  const minutes = Math.floor((totalSeconds % 3600) / 60);
		  const seconds = totalSeconds % 60;
		  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
		}

		function updateTimer() {
		  const currentTime = Math.floor((Date.now() - startTime) / 1000) + elapsedTime;
		  timerDisplay.textContent = formatTime(currentTime);
		}

		function toggleTimer() {
		  if (!isRunning) {
			startTime = Date.now();
			timerInterval = setInterval(updateTimer, 1000);
			playIcon.style.display = 'none';
			pauseIcon.style.display = 'block';
		  } else {
			clearInterval(timerInterval);
			elapsedTime += Math.floor((Date.now() - startTime) / 1000);
			playIcon.style.display = 'block';
			pauseIcon.style.display = 'none';
		  }
		  isRunning = !isRunning;
		}

		function resetTimer() {
		  clearInterval(timerInterval);
		  isRunning = false;
		  elapsedTime = 0;
		  timerDisplay.textContent = '00:00:00';
		  playIcon.style.display = 'block';
		  pauseIcon.style.display = 'none';
		}

		startPauseBtn.addEventListener('click', toggleTimer);
		resetBtn.addEventListener('click', resetTimer);

		// Initialize timer display
		resetTimer();

		function initializePuzzleCounter(rows, cols) {
			totalPiecesCount = rows * cols;
		
			// 住专转  拽  拽
			const existingCounter = document.querySelector('.puzzle-counter');
			if (existingCounter) {
				existingCounter.remove();
			}
			
			// 爪专转  砖
			puzzleCounter = document.createElement('div');
			puzzleCounter.className = 'puzzle-counter';
			document.body.appendChild(puzzleCounter);
			
			// 转 砖 砖  注 注专 转转
			puzzleCounter.style.transform = 'scale(1)';
			puzzleCounter.style.opacity = '1';
			updatePuzzleCounter(totalPiecesCount);
		}

		function updatePuzzleCounter(remainingPieces) {
			if (!puzzleCounter) return;

			puzzleCounter.innerHTML = `
				<div style="font-size: 24px; margin-bottom: 5px;">${remainingPieces}</div>
				<div style="font-size: 14px;">拽 转专</div>
			`;

			// 住驻转 驻拽 
			puzzleCounter.classList.add('pulse');
			setTimeout(() => puzzleCounter.classList.remove('pulse'), 300);

			// 砖 爪注 驻 转拽转
			const progress = (totalPiecesCount - remainingPieces) / totalPiecesCount;
			const hue = progress * 120;
			puzzleCounter.style.background = `linear-gradient(145deg, 
				hsla(${hue}, 70%, 30%, 0.9),
				hsla(${hue}, 70%, 40%, 0.9)
			)`;

			// 住转专 住
			if (remainingPieces === 0) {
				setTimeout(() => {
					puzzleCounter.style.transform = 'scale(0)';
					puzzleCounter.style.opacity = '0';
				}, 1500);
			}
		}

		function isNearCorrectPosition(piece, pos) {
			if (!pos) return false;
			
			const distance = Math.sqrt(
				Math.pow(piece.x - pos.x, 2) + 
				Math.pow(piece.y - pos.y, 2)
			);

			return distance < snapDistance; // snapDistance 爪专 转 专 拽 转
		}


        function initialize() {
            canvas = document.getElementById('puzzleCanvas');
            ctx = canvas.getContext('2d');

            //  专注
            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
            document.getElementById('modeToggle').addEventListener('change', (e) => {
                isGuidedMode = e.target.checked;
                showStatus(isGuidedMode ? '爪 专 驻注' : '爪 驻砖 驻注');
            });

            window.addEventListener('resize', updateCanvasSize);
            setupCanvasInteraction();
        }

        function setupCanvasInteraction() {
			// Mouse events
			canvas.addEventListener('mousedown', startDragging);
			canvas.addEventListener('mousemove', dragPiece);
			canvas.addEventListener('mouseup', stopDragging);
			canvas.addEventListener('mouseleave', stopDragging);

			// Touch events
			canvas.addEventListener('touchstart', startDragging);
			canvas.addEventListener('touchmove', dragPiece);
			canvas.addEventListener('touchend', stopDragging);
		}

		function getEventCoordinates(e) {
			// Check if it's a touch event
			if (e.touches && e.touches.length > 0) {
				return {
					x: e.touches[0].clientX,
					y: e.touches[0].clientY
				};
			}
			// If not, use mouse event coordinates
			return {
				x: e.clientX,
				y: e.clientY
			};
		}

        function startDragging(e) {
			e.preventDefault(); // Prevents unintended behavior on touch devices
			const rect = canvas.getBoundingClientRect();
			const coords = getEventCoordinates(e);
			const x = coords.x - rect.left;
			const y = coords.y - rect.top;

			// Check if a piece was clicked/touched
			for (let i = puzzlePieces.length - 1; i >= 0; i--) {
				const piece = puzzlePieces[i];
				if (isPointInPiece(x, y, piece)) {
					isDragging = true;
					currentPiece = piece;
					offsetX = x - piece.x;
					offsetY = y - piece.y;
					piece.isDragging = true;

					// Bring the selected piece to the front
					puzzlePieces.splice(i, 1);
					puzzlePieces.push(piece);

					drawPuzzle();
					break;
				}
			}
		}

        function dragPiece(e) {
			if (!isDragging || !currentPiece) return;
			e.preventDefault(); // Prevent scrolling on touch devices

			const rect = canvas.getBoundingClientRect();
			const coords = getEventCoordinates(e);
			const x = coords.x - rect.left;
			const y = coords.y - rect.top;

			currentPiece.x = x - offsetX;
			currentPiece.y = y - offsetY;

			if (isGuidedMode) {
				// Check proximity to correct position
				const correctPos = piecePositions[currentPiece.index];
				const distance = Math.hypot(
					currentPiece.x - correctPos.x,
					currentPiece.y - correctPos.y
				);

				if (distance < 30) { // Snap distance
					currentPiece.x = correctPos.x;
					currentPiece.y = correctPos.y;
					currentPiece.isPlaced = true;

					// Update the counter
					const placedPieces = puzzlePieces.filter(p => p.isPlaced).length;
					const remaining = totalPiecesCount - placedPieces;
					updatePuzzleCounter(remaining);
				}
			}

			drawPuzzle();
		}
				
		

        function stopDragging() {
			if (currentPiece) {
				currentPiece.isDragging = false;
				if (currentPiece.isPlaced) {
					showStatus('拽  拽 !');
					checkPuzzleCompletion();
				}
			}
			isDragging = false;
			currentPiece = null;
			drawPuzzle();
		}

        // 驻拽爪转 注专 拽  拽 爪转 转 拽
		function isPointInPiece(x, y, piece) {
			return x >= piece.x && 
				   x <= piece.x + piece.width && 
				   y >= piece.y && 
				   y <= piece.y + piece.height;
		}

		
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.onload = function () {
                    originalImage = img;
                    document.getElementById('previewImage').src = event.target.result;
                    updateCanvasSize();
                    drawPreview();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleCreatePuzzle() {
            if (!originalImage) {
                showStatus(' 注转 转 转');
                return;
            }

            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            const puzzleType = document.querySelector('input[name="puzzleType"]:checked').value;

            gridSize = { rows, cols };
            createPuzzle(rows, cols, puzzleType);
            showStatus('驻 爪专! 专专 转 拽 拽');
        }

        // 爪专 转爪 拽
        function drawPreview() {
            if (!originalImage) return;

            const ratio = Math.min(
                canvas.width / originalImage.width,
                canvas.height / originalImage.height
            );

            const newWidth = originalImage.width * ratio;
            const newHeight = originalImage.height * ratio;
            const x = (canvas.width - newWidth) / 2;
            const y = (canvas.height - newHeight) / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, x, y, newWidth, newHeight);
        }

        function createPuzzle(rows, cols, type) {
            // 驻住
            puzzlePieces = [];
            piecePositions = [];
			edgeTypes = null;

			// 驻住 砖转 转转 驻 砖
			isPuzzleCompleted = false;
	
			// 住驻转 转 
			initializePuzzleCounter(rows, cols);
	
            // 砖 
            const ratio = Math.min(
                canvas.width / originalImage.width,
                canvas.height / originalImage.height
            );
            const gameWidth = originalImage.width * ratio;
            const gameHeight = originalImage.height * ratio;
            const pieceWidth = gameWidth / cols;
            const pieceHeight = gameHeight / rows;
            const startX = (canvas.width - gameWidth) / 2;
            const startY = (canvas.height - gameHeight) / 2;

            // 爪专转 拽
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // 砖 拽 拽专 转
                    const srcX = col * (originalImage.width / cols);
                    const srcY = row * (originalImage.height / rows);

                    // 砖 拽 住驻
                    const finalX = startX + (col * pieceWidth);
                    const finalY = startY + (row * pieceHeight);

                    // 砖专转 拽 
                    piecePositions.push({
                        x: finalX,
                        y: finalY,
                        row: row,
                        col: col
                    });

                    // 爪专转 拽 砖
                    const piece = {
                        index: row * cols + col,
                        srcX: srcX,
                        srcY: srcY,
                        width: pieceWidth,
                        height: pieceHeight,
                        isPlaced: false,
                        isDragging: false
                    };

                    // 拽注转 拽 专 专拽 住 转 爪转, 转 砖专 注 拽 转 住专转
                    let randomPosition = Math.random();
                    if (randomPosition < 0.25) {
                        // 注 转,  砖拽 砖专 住专转 拽住
                        piece.x = startX + Math.random() * (gameWidth - piece.width);
                        piece.y = Math.max(0, startY - piece.height - Math.random() * (startY - piece.height));
                    } else if (randomPosition < 0.5) {
                        // 转转 转,  砖拽 砖专 住专转 拽住
                        piece.x = startX + Math.random() * (gameWidth - piece.width);
                        piece.y = Math.min(canvas.height - piece.height, startY + gameHeight + Math.random() * (canvas.height - (startY + gameHeight) - piece.height));
                    } else if (randomPosition < 0.75) {
                        // 爪 砖 砖 转,  砖拽 砖专 住专转 拽住
                        piece.x = Math.max(0, startX - piece.width - Math.random() * (startX - piece.width));
                        piece.y = startY + Math.random() * (gameHeight - piece.height);
                    } else {
                        // 爪  砖 转,  砖拽 砖专 住专转 拽住
                        piece.x = Math.min(canvas.width - piece.width, startX + gameWidth + Math.random() * (canvas.width - (startX + gameWidth) - piece.width));
                        piece.y = startY + Math.random() * (gameHeight - piece.height);
                    }


                    if (type === 'classic') {
                        piece.edges = generateClassicEdges(row, col, rows, cols);
                    }

                    puzzlePieces.push(piece);
                }
            }


            // 住驻转 驻转专 驻专
            addShuffleButton();

            drawPuzzle();
			
			toggleTimer();
        }

        function generateClassicEdges(row, col, rows, cols) {
            // 转 注专 专 转转 驻 砖
            if (!edgeTypes) {
                edgeTypes = Array(rows).fill().map(() => Array(cols).fill().map(() => ({})));
            }

            const edges = {};

            // 拽注转 专 驻 砖注 专 驻
            if (row === 0) {
                edges.top = 'none';
            } else {
                edges.top = edgeTypes[row - 1][col].bottom === 'tab' ? 'blank' : 'tab';
            }

            if (col === 0) {
                edges.left = 'none';
            } else {
                edges.left = edgeTypes[row][col - 1].right === 'tab' ? 'blank' : 'tab';
            }

            if (row === rows - 1) {
                edges.bottom = 'none';
            } else {
                edges.bottom = ((row + col) % 2 === 0) ? 'blank' : 'tab';
            }

            if (col === cols - 1) {
                edges.right = 'none';
            } else {
                edges.right = ((row + col) % 2 === 0) ? 'tab' : 'blank';
            }

            // 砖专转 专 注 拽 
            edgeTypes[row][col] = edges;

            return edges;
        }

        function drawPuzzle() {
		
			if (!originalImage) return;
		
			// 拽 拽住
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// 砖 住 转转 专拽注
			const ratio = Math.min(
				canvas.width / originalImage.width,
				canvas.height / originalImage.height
			);

			// 爪专 转 拽专转 专拽注 注 砖拽驻转
			ctx.save();
			ctx.globalAlpha = 0.1; // 砖拽驻转 砖 10%
			const bgWidth = originalImage.width * ratio;
			const bgHeight = originalImage.height * ratio;
			const bgX = (canvas.width - bgWidth) / 2;
			const bgY = (canvas.height - bgHeight) / 2;
			
			ctx.drawImage(
				originalImage,
				bgX, bgY,
				bgWidth, bgHeight
			);
			ctx.globalAlpha = 1;
			ctx.restore();

			// 爪专转 注专 驻专 拽 专 驻砖
			const placedPieces = puzzlePieces.filter(piece => piece.isPlaced);
			const freePieces = puzzlePieces.filter(piece => !piece.isPlaced);

			// 专拽 砖   - 驻转 住专 砖 拽 驻砖
			placedPieces.sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
			freePieces.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));  // 砖  

			// 砖专 拽 砖专 拽 转 专
			if (placedPieces.length > 0) {
				ctx.save();
				ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
				ctx.shadowBlur = 15;
				ctx.shadowOffsetX = 5;
				ctx.shadowOffsetY = 5;

				placedPieces.forEach(piece => {
					if (!piece.isDragging) {
						if (document.querySelector('input[name="puzzleType"]:checked').value === 'classic') {
							drawClassicPiece(piece);
						} else {
							drawSimplePiece(piece);
						}
					}
				});
				ctx.restore();
			}

			freePieces.forEach(piece => {
				ctx.save();
				
				if (!piece.isDragging) {
					ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
					ctx.shadowBlur = 10;
					ctx.shadowOffsetX = 3;
					ctx.shadowOffsetY = 3;
				}

				if (piece.isDragging) {
					ctx.shadowColor = 'rgba(52, 152, 219, 0.5)';
					ctx.shadowBlur = 20;
					ctx.shadowOffsetX = 0;
					ctx.shadowOffsetY = 0;
				}

				if (document.querySelector('input[name="puzzleType"]:checked').value === 'classic') {
					drawClassicPiece(piece);
				} else {
					drawSimplePiece(piece);
				}
				ctx.restore();

				if (piece.isDragging && isGuidedMode) {
					const nearbyPiece = findNearbyPiece(piece);
					if (nearbyPiece) {
						ctx.save();
						ctx.strokeStyle = '#3498db';
						ctx.lineWidth = 3;
						ctx.setLineDash([5, 5]);
						ctx.strokeRect(
							nearbyPiece.x - 5,
							nearbyPiece.y - 5,
							nearbyPiece.width + 10,
							nearbyPiece.height + 10
						);
						ctx.restore();
					}
				}
			});

			const draggingPiece = puzzlePieces.find(piece => piece.isDragging);
			if (draggingPiece) {
				ctx.save();
				ctx.shadowColor = 'rgba(52, 152, 219, 0.5)';
				ctx.shadowBlur = 20;
				ctx.shadowOffsetX = 0;
				ctx.shadowOffsetY = 0;

				if (document.querySelector('input[name="puzzleType"]:checked').value === 'classic') {
					drawClassicPiece(draggingPiece);
				} else {
					drawSimplePiece(draggingPiece);
				}
				ctx.restore();
			}

			if (placedPieces.length === puzzlePieces.length) {
				checkPuzzleCompletion();
			}

			if (typeof updateRemainingPiecesCount === 'function') {
				updateRemainingPiecesCount();
			}
		}

        // 注 驻 爪 注 拽
        function handlePieceClick(event) {
            const piece = findClickedPiece(event);
            if (piece) {
                piece.zIndex = Math.max(...puzzlePieces.map(p => p.zIndex || 0)) + 1;
                piece.isDragging = true;
                drawPuzzle();
            }
        }

		// 注 驻拽爪转 爪转 拽 砖抓
		function findClickedPiece(e) {
			const rect = canvas.getBoundingClientRect();
			const mouseX = e.clientX - rect.left;
			const mouseY = e.clientY - rect.top;

			 // 住专 拽 驻 z-index 住专 专
			const sortedPieces = [...puzzlePieces]
				.filter(piece => !piece.isPlaced)  // 专拽 拽 驻砖
				.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));  //  

			// 专 转 拽 注 转专 砖抓
			return sortedPieces.find(piece => 
				mouseX >= piece.x && 
				mouseX <= piece.x + piece.width &&
				mouseY >= piece.y && 
				mouseY <= piece.y + piece.height
			);
		}

        function drawGuideLines() {
            const ratio = Math.min(
                canvas.width / originalImage.width,
                canvas.height / originalImage.height
            );

            const gameWidth = originalImage.width * ratio;
            const gameHeight = originalImage.height * ratio;
            const startX = (canvas.width - gameWidth) / 2;
            const startY = (canvas.height - gameHeight) / 2;

            ctx.strokeStyle = 'rgba(52, 152, 219, 0.2)';
            ctx.lineWidth = 1;

            // 拽 
            for (let i = 0; i <= gridSize.cols; i++) {
                const x = startX + (i * gameWidth / gridSize.cols);
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, startY + gameHeight);
                ctx.stroke();
            }

            // 拽 驻拽
            for (let i = 0; i <= gridSize.rows; i++) {
                const y = startY + (i * gameHeight / gridSize.rows);
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(startX + gameWidth, y);
                ctx.stroke();
            }
        }

        function drawPiece(piece) {
            ctx.save();

            // 驻拽 拽 专专
            if (piece.isDragging) {
                ctx.shadowColor = 'rgba(52, 152, 219, 0.5)';
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }

            // 爪专 拽 注爪
            if (document.querySelector('input[name="puzzleType"]:checked').value === 'classic') {
                drawClassicPiece(piece);
            } else {
                drawSimplePiece(piece);
            }

            ctx.restore();
        }

        function drawClassicPiece(piece) {
            const tabSize = piece.width * 0.2;

            ctx.beginPath();
            ctx.moveTo(piece.x, piece.y);

            // 爪专 爪 注
            if (piece.edges.top === 'tab') {
                drawTab(ctx,
                    piece.x, piece.y,
                    piece.x + piece.width, piece.y,
                    tabSize, true
                );
            } else if (piece.edges.top === 'blank') {
                drawTab(ctx,
                    piece.x, piece.y,
                    piece.x + piece.width, piece.y,
                    tabSize, false
                );
            } else {
                ctx.lineTo(piece.x + piece.width, piece.y);
            }

            // 爪专 爪 
            if (piece.edges.right === 'tab') {
                drawTab(ctx,
                    piece.x + piece.width, piece.y,
                    piece.x + piece.width, piece.y + piece.height,
                    tabSize, true
                );
            } else if (piece.edges.right === 'blank') {
                drawTab(ctx,
                    piece.x + piece.width, piece.y,
                    piece.x + piece.width, piece.y + piece.height,
                    tabSize, false
                );
            } else {
                ctx.lineTo(piece.x + piece.width, piece.y + piece.height);
            }

            // 爪专 爪 转转
            if (piece.edges.bottom === 'tab') {
                drawTab(ctx,
                    piece.x + piece.width, piece.y + piece.height,
                    piece.x, piece.y + piece.height,
                    tabSize, true
                );
            } else if (piece.edges.bottom === 'blank') {
                drawTab(ctx,
                    piece.x + piece.width, piece.y + piece.height,
                    piece.x, piece.y + piece.height,
                    tabSize, false
                );
            } else {
                ctx.lineTo(piece.x, piece.y + piece.height);
            }

            // 爪专 爪 砖
            if (piece.edges.left === 'tab') {
                drawTab(ctx,
                    piece.x, piece.y + piece.height,
                    piece.x, piece.y,
                    tabSize, true
                );
            } else if (piece.edges.left === 'blank') {
                drawTab(ctx,
                    piece.x, piece.y + piece.height,
                    piece.x, piece.y,
                    tabSize, false
                );
            } else {
                ctx.lineTo(piece.x, piece.y);
            }

            ctx.closePath();
            ctx.save();
            ctx.clip();

            // 砖  住 转拽 转
            const overlapRatio = 0.4; // 转 专 -40%

            // 砖 拽  转 拽专转
            const sourceWidth = originalImage.width / gridSize.cols;
            const sourceHeight = originalImage.height / gridSize.rows;
            const extraSource = Math.max(sourceWidth, sourceHeight) * overlapRatio;

            // 砖 拽 转 拽专转 注 转住驻转 砖 拽转 转
            const srcX = Math.max(0, piece.srcX - extraSource);
            const srcY = Math.max(0, piece.srcY - extraSource);
            const srcWidth = Math.min(sourceWidth + extraSource * 2, originalImage.width - srcX);
            const srcHeight = Math.min(sourceHeight + extraSource * 2, originalImage.height - srcY);

            // 砖 住 注 住 转 住 拽专
            const destOffsetX = (piece.srcX - srcX) * (piece.width / sourceWidth);
            const destOffsetY = (piece.srcY - srcY) * (piece.height / sourceHeight);

            // 砖  注 住驻
            const destWidth = srcWidth * (piece.width / sourceWidth);
            const destHeight = srcHeight * (piece.height / sourceHeight);

            // 爪专 转 注  转转
            ctx.drawImage(
                originalImage,
                srcX, srcY,
                srcWidth, srcHeight,
                piece.x - destOffsetX, piece.y - destOffsetY,
                destWidth, destHeight
            );

            ctx.restore();

            // 爪专 住专转
            ctx.strokeStyle = piece.isDragging ? '#3498db' : '#2c3e50';
            ctx.lineWidth = piece.isDragging ? 3 : 1;
            ctx.stroke();
        }

        function drawTab(ctx, x1, y1, x2, y2, size, isTab) {
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1);

            //  拽 转专 注 砖驻专 驻专驻专爪转
            const controlPoint = isTab ? size * 0.9 : -size * 0.9;
            const depthRatio = 0.15;  // 注拽 转 转

            // 拽转  专砖
            ctx.lineTo(
                midX - Math.cos(angle) * (distance * depthRatio),
                midY - Math.sin(angle) * (distance * depthRatio)
            );

            // 注拽 专转
            ctx.quadraticCurveTo(
                midX + Math.cos(angle + Math.PI / 2) * controlPoint,
                midY + Math.sin(angle + Math.PI / 2) * controlPoint,
                midX + Math.cos(angle) * (distance * depthRatio),
                midY + Math.sin(angle) * (distance * depthRatio)
            );

            // 砖 拽 住驻转
            ctx.lineTo(x2, y2);
        }


        function determineEdgeType(row, col, edge) {
            // 转 注专   拽
            if (!edgeTypes) {
                edgeTypes = Array(gridSize.rows).fill().map(() => Array(gridSize.cols).fill().map(() => ({})));
            }

            //  专 拽注 住 专, 砖转砖 
            if (edgeTypes[row]?.[col]?.[edge]) {
                return edgeTypes[row][col][edge];
            }

            let type;
            switch (edge) {
                case 'top':
                    if (row === 0) return 'none';
                    // 爪 注  驻 爪 转转 砖 拽 砖注
                    type = edgeTypes[row - 1]?.[col]?.bottom ?
                        (edgeTypes[row - 1][col].bottom === 'tab' ? 'blank' : 'tab') :
                        ((row + col) % 2 === 0 ? 'tab' : 'blank');
                    break;

                case 'right':
                    if (col === gridSize.cols - 1) return 'none';
                    // 爪  拽注 驻 拽
                    type = (row + col) % 2 === 0 ? 'tab' : 'blank';
                    break;

                case 'bottom':
                    if (row === gridSize.rows - 1) return 'none';
                    // 爪 转转 拽注 驻 拽
                    type = (row + col) % 2 !== 0 ? 'tab' : 'blank';
                    break;

                case 'left':
                    if (col === 0) return 'none';
                    // 爪 砖  驻 爪  砖 拽 砖
                    type = edgeTypes[row]?.[col - 1]?.right ?
                        (edgeTypes[row][col - 1].right === 'tab' ? 'blank' : 'tab') :
                        ((row + col) % 2 !== 0 ? 'tab' : 'blank');
                    break;
            }

            // 砖专转 住 砖拽注
            if (!edgeTypes[row][col]) edgeTypes[row][col] = {};
            edgeTypes[row][col][edge] = type;

            return type;
        }


        function drawSimpleTab(ctx, x1, y1, x2, y2, size, isTab) {
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1);

            // 砖驻专 爪专转 
            const controlPoint = isTab ? size * 0.9 : -size * 0.9;
            const depthRatio = 0.15; // 拽转 注拽 专

            // 拽转 转
            ctx.lineTo(
                midX - Math.cos(angle) * (distance * depthRatio),
                midY - Math.sin(angle) * (distance * depthRatio)
            );

            //  拽 转专
            ctx.quadraticCurveTo(
                midX + Math.cos(angle + Math.PI / 2) * controlPoint,
                midY + Math.sin(angle + Math.PI / 2) * controlPoint,
                midX + Math.cos(angle) * (distance * depthRatio),
                midY + Math.sin(angle) * (distance * depthRatio)
            );

            ctx.lineTo(x2, y2);
        }



        function drawSimplePiece(piece) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(piece.x, piece.y, piece.width, piece.height);
            ctx.clip();

            // 爪专 转
            ctx.drawImage(
                originalImage,
                piece.srcX, piece.srcY,
                originalImage.width / gridSize.cols,
                originalImage.height / gridSize.rows,
                piece.x, piece.y,
                piece.width, piece.height
            );

            ctx.restore();

            // 住驻转 住专转 (抓 -clip)
            ctx.beginPath();
            ctx.rect(piece.x, piece.y, piece.width, piece.height);
            ctx.strokeStyle = piece.isDragging ? '#3498db' : '#2c3e50';
            ctx.lineWidth = piece.isDragging ? 3 : 1;
            ctx.stroke();
        }

        function updateCanvasSize() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            if (puzzlePieces.length > 0) {
                drawPuzzle();
            } else if (originalImage) {
                drawPreview();
            }
        }

        // 住祝 驻转专 驻专 砖 砖 拽 驻砖
        function addShuffleButton() {
            const button = document.createElement('button');
            button.textContent = '驻专 拽 驻砖';
            button.className = 'shuffle-free-pieces';
            button.style.cssText = `
				position: fixed;
				bottom: 20px;
				right: 20px;
				padding: 10px 20px;
				background: #3498db;
				color: white;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				z-index: 1000;
			`;

            button.addEventListener('click', shuffleFreePieces);
            document.body.appendChild(button);
        }

        // 驻拽爪 驻专 拽 驻砖
        function shuffleFreePieces() {
            puzzlePieces.forEach(piece => {
                if (!piece.isPlaced) {
                    // 砖砖 拽转 驻专 拽专转 砖
                    let randomPosition = Math.random();
                    const gameWidth = canvas.width * 0.8;  // 80% 专 拽住
                    const gameHeight = canvas.height * 0.8; // 80%  拽住
                    const startX = canvas.width * 0.1;     // 10% 砖
                    const startY = canvas.height * 0.1;    // 10% 砖

                    if (randomPosition < 0.25) {
                        piece.x = startX + Math.random() * (gameWidth - piece.width);
                        piece.y = Math.max(0, startY - piece.height - Math.random() * (startY - piece.height));
                    } else if (randomPosition < 0.5) {
                        piece.x = startX + Math.random() * (gameWidth - piece.width);
                        piece.y = Math.min(canvas.height - piece.height, startY + gameHeight + Math.random() * (canvas.height - (startY + gameHeight) - piece.height));
                    } else if (randomPosition < 0.75) {
                        piece.x = Math.max(0, startX - piece.width - Math.random() * (startX - piece.width));
                        piece.y = startY + Math.random() * (gameHeight - piece.height);
                    } else {
                        piece.x = Math.min(canvas.width - piece.width, startX + gameWidth + Math.random() * (canvas.width - (startX + gameWidth) - piece.width));
                        piece.y = startY + Math.random() * (gameHeight - piece.height);
                    }

                    // 专转 z-index  拽 驻砖
                    piece.zIndex = 1000;
                }
            });

            drawPuzzle();
        }

        function checkPuzzleCompletion() {
			//  驻 专 砖,  爪专 砖
			if (isPuzzleCompleted) return;
			
			// 拽   拽 拽
			const allPlaced = puzzlePieces.every(piece => piece.isPlaced);
			
			if (allPlaced) {
				isPuzzleCompleted = true; // 住 砖驻 砖
				createCompletionEffect();
			}
		}

        function createCompletionEffect() {
			// 爪专转 砖转 驻拽
			const effectLayer = document.createElement('div');
			effectLayer.style.cssText = `
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
				pointer-events: none;
				opacity: 0;
				transition: opacity 0.5s ease;
				z-index: 9999;
			`;
			document.body.appendChild(effectLayer);

			// 爪转 专
			setTimeout(() => {
				effectLayer.style.opacity = '1';
				
				// 爪专转 拽驻
				createConfetti();
				
				// 爪转 注转 住
				const completionMessage = document.createElement('div');
				completionMessage.style.cssText = `
					position: fixed;
					top: 50%;
					left: 50%;
					transform: translate(-50%, -50%);
					background: rgba(0, 0, 0, 0.8);
					color: white;
					padding: 20px 40px;
					border-radius: 10px;
					font-size: 24px;
					text-align: center;
					z-index: 10000;
					animation: messagePopIn 0.5s ease forwards;
				`;
				completionMessage.textContent = ' ! 砖转 转 驻! ';
				document.body.appendChild(completionMessage);

				// 住专转 驻拽 专 3 砖转
				setTimeout(() => {
					toggleTimer();
					effectLayer.style.opacity = '0';
					completionMessage.style.animation = 'messagePopOut 0.5s ease forwards';
					setTimeout(() => {
						effectLayer.remove();
						completionMessage.remove();
						resetTimer();
					}, 500);
				}, 3000);
			}, 100);
		}

        function createConfetti() {
            const confettiCanvas = document.createElement('canvas');
            confettiCanvas.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                pointer-events: none; z-index: 9999;
            `;
            const dpr = window.devicePixelRatio || 1;
            confettiCanvas.width = window.innerWidth * dpr;
            confettiCanvas.height = window.innerHeight * dpr;
            document.body.appendChild(confettiCanvas);
            const cCtx = confettiCanvas.getContext('2d');
            cCtx.scale(dpr, dpr);

            const colors = ['#ff0', '#f0f', '#0ff', '#0f0', '#f90', '#f44'];
            const particles = Array.from({length: 80}, () => ({
                x: Math.random() * window.innerWidth,
                y: -20 - Math.random() * 100,
                size: Math.random() * 8 + 4,
                color: colors[Math.floor(Math.random() * colors.length)],
                speed: Math.random() * 3 + 2,
                wobble: Math.random() * 4 - 2,
                rotation: Math.random() * 360,
                rotSpeed: Math.random() * 10 - 5
            }));

            let frame;
            const startTime = Date.now();
            function animate() {
                const elapsed = Date.now() - startTime;
                if (elapsed > 3000) {
                    cancelAnimationFrame(frame);
                    confettiCanvas.remove();
                    return;
                }
                cCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                const fade = elapsed > 2500 ? 1 - (elapsed - 2500) / 500 : 1;
                particles.forEach(p => {
                    p.y += p.speed;
                    p.x += p.wobble * Math.sin(p.y / 30);
                    p.rotation += p.rotSpeed;
                    cCtx.save();
                    cCtx.globalAlpha = fade;
                    cCtx.translate(p.x, p.y);
                    cCtx.rotate(p.rotation * Math.PI / 180);
                    cCtx.fillStyle = p.color;
                    cCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    cCtx.restore();
                });
                frame = requestAnimationFrame(animate);
            }
            frame = requestAnimationFrame(animate);
        }


        function showStatus(message, duration = 2000) {
            if (statusTimeout) {
                clearTimeout(statusTimeout);
            }

            const status = document.getElementById('status');
            status.textContent = message;
            status.classList.add('show');

            statusTimeout = setTimeout(() => {
                status.classList.remove('show');
            }, duration);
        }

        // 住驻转 住 爪转
        const style = document.createElement('style');
        style.textContent = `
            @keyframes confettiFall {
                0% {
                    transform: translateY(0) rotate(0deg);
                    opacity: 1;
                }
                100% {
                    transform: translateY(100vh) rotate(720deg);
                    opacity: 0;
                }
            }

            @keyframes messagePopIn {
                0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }

            @keyframes messagePopOut {
                0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

    </script>
</body>

</html>